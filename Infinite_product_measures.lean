/- It is fine to import all of Mathlib in your project.
This might make the loading time of a file a bit longer. If you want a good chunk of Mathlib, but not everything, you can `import Mathlib.Tactic` and then add more imports as necessary. -/
import IonescuTulcea
import Mathlib
-- import Mathlib.MeasureTheory.Measure.ProbabilityMeasure

set_option autoImplicit true
/- open namespaces that you use to shorten names and enable notation. -/
open Function Set Classical ENNReal

/- recommended whenever you define anything new. -/
noncomputable section


/- Now write definitions and theorems. -/
namespace MeasureTheory

theorem SetAlgebraIsSetSemiRing (h1 : IsSetAlgebra S) : IsSetSemiring S := by {
  refine IsSetRing.isSetSemiring ?_
  exact IsSetAlgebra.isSetRing h1
}

-- def LE.lesser [les : LE Œ±] (x : les.le a b) := a
def lesser {Œ± : Type} [LE Œ±] {x y : Œ±} (h : x ‚â§ y) : Œ± :=
  x
def greater {Œ± : Type} [LE Œ±] {x y : Œ±} (h : x ‚â§ y) : Œ± :=
  y


open Filter Topology

variable {Œ± : Type*} {S : Set (Set Œ±)} [mŒ± : MeasurableSpace Œ±] (Œº : AddContent S)


lemma AddContent.additive (A B : Set Œ±) (hAB : Disjoint A B) : Œº (A ‚à™ B) = Œº A + Œº B := by {
  sorry
}
-- lemma AddContent.mono (A B : Set Œ±) (hAB : Disjoint A B) : Œº (A ‚à™ B) = Œº A + Œº B := by {
--   sorry
-- }
  -- := by {

  -- }

def AddContent.sAdditive : Prop :=
  ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ, (‚àÄ i, (A i) ‚àà S) -> (‚ãÉ i, A i ‚àà S) ‚Üí Pairwise (Disjoint on A) ‚Üí
    Œº (‚ãÉ i, A i) = ‚àë' i, Œº (A i)

def AddContent.sSubAdditive  : Prop :=
  ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ, (‚àÄ i, (A i) ‚àà S) -> (‚ãÉ i, A i ‚àà S) ‚Üí
    Œº (‚ãÉ i, A i) <= ‚àë' i, Œº (A i)

def AddContent.sContinuousFromBelow  : Prop :=
  ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ {B : Set Œ± }, (‚àÄ i, (A i) ‚àà S) -> (B ‚àà S) ->
  (Tendsto A atTop (ùìù[‚â§] B)) ->
  Tendsto (Œª n => Œº (A n)) atTop (ùìù (Œº B))

def AddContent.sContinuousFromAbove  : Prop :=
  ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ (B : Set Œ±), (‚àÄ i, (A i) ‚àà S) -> (B ‚àà S) -> (Œº (A 0) < ‚àû) ->
  (Tendsto A atTop (ùìù[‚â•] B)) ->
  Tendsto (Œª n => Œº (A n)) atTop (ùìù (Œº B))

def AddContent.sContinuousInEmpty  : Prop :=
  ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ, (‚àÄ i, (A i) ‚àà S) -> (Œº (A 0) < ‚àû) ->
  (Tendsto A atTop (ùìù ‚àÖ)) ->
  Tendsto (Œª n => Œº (A n)) atTop (ùìù 0)

lemma sAdditive_implies_sSubAdditive : Œº.sAdditive -> Œº.sSubAdditive := sorry
lemma sSubAdditive_implies_sAdditive : Œº.sSubAdditive -> Œº.sAdditive := sorry

lemma sAdditive_implies_sContinuousFromBelow : Œº.sAdditive -> Œº.sContinuousFromBelow := sorry
lemma sContinuousFromBelow_implies_sAdditive : Œº.sContinuousFromBelow -> Œº.sAdditive := sorry

lemma sContinuousFromAbove_implies_sContinuousInEmpty : Œº.sContinuousFromAbove -> Œº.sContinuousInEmpty := sorry
lemma sContinuousInEmpty_implies_sContinuousFromAbove : Œº.sContinuousInEmpty -> Œº.sContinuousFromAbove := sorry

lemma sAdditive_implies_sContinuousInEmpty : Œº.sAdditive -> Œº.sContinuousInEmpty := sorry

lemma sContinuousInEmpty_finite_implies_sAdditive : Œº.sContinuousInEmpty ‚àß Œº univ < ‚àû -> Œº.sAdditive := sorry

  -- ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ, (‚àÄ i, (A i) ‚àà S) -> (Œº (A 0) < ‚àû) ->
  -- (Tendsto A atTop (ùìù[‚â•] B)) ->
  --   Tendsto (Œª n => Œº (A n)) atTop (ùìù 0)


def AddContent.toOuterMeasure :=
    inducedOuterMeasure (Œª s : Set Œ± => Œª _ : s ‚àà S => Œº s)

variable (hAlg : IsSetAlgebra S)

lemma addContent_outer_measure_equal_on_S (s : Set Œ±) (hs : s ‚àà S) (hŒº : Œº.sAdditive)
  : Œº.toOuterMeasure hAlg.empty_mem Œº.empty' s = Œº s := by {
      -- generalize h : Œº.toOuterMeasure hAlg.empty_mem Œº.empty' = ŒΩ
      let ŒΩ := Œº.toOuterMeasure hAlg.empty_mem Œº.empty'
      suffices ŒΩ s <= Œº s ‚àß ŒΩ s >= Œº s by exact le_antisymm this.1 this.2
      constructor
      ¬∑
        unfold ŒΩ AddContent.toOuterMeasure inducedOuterMeasure OuterMeasure.ofFunction
        rw [‚Üê @OuterMeasure.measureOf_eq_coe]
        simp
        let f : ‚Ñï -> Set Œ± := fun n => if n = 0 then s else ‚àÖ
        have hf : ‚ãÉ i, f i = s := by ext; simp [f]
        calc
        ‚®Ö f : ‚Ñï -> Set Œ±, ‚®Ö (_ : s ‚äÜ ‚ãÉ i, f i), ‚àë' (i : ‚Ñï), extend (fun s x ‚Ü¶ Œº s) (f i)
        <= ‚®Ö (_ : s ‚äÜ ‚ãÉ i, f i), ‚àë' (i : ‚Ñï),
          extend (P := Membership.mem S) (fun s x ‚Ü¶ Œº s) (f i) := by apply iInf_le
        _ =  ‚àë' (i : ‚Ñï), extend (P := Membership.mem S) (fun s x ‚Ü¶ Œº s) (f i) := by simp [hf]
        _ =  Œº s := by {
          unfold f
          simp [apply_ite, extend_eq (fun s x => Œº s)]
          rw [show extend (P := Membership.mem S) (fun s x => Œº s) s = Œº s by {
            exact extend_eq (fun s x ‚Ü¶ Œº s) hs
          }]
          rw [show extend (P := Membership.mem S) (fun s x => Œº s) ‚àÖ = 0 by {
            have h := extend_eq (fun s x ‚Ü¶ Œº s) hAlg.empty_mem
            simp at h
            exact h
          }]
          simp
        }
      ¬∑
        rw [ge_iff_le]
        unfold ŒΩ AddContent.toOuterMeasure inducedOuterMeasure OuterMeasure.ofFunction
        rw [‚Üê OuterMeasure.measureOf_eq_coe]
        simp
        intro A hA
        by_cases hAS : ‚àÄn, A n ‚àà S
        ¬∑
          calc Œº s = Œº ((‚ãÉn, A n) ‚à© s) := by rw [inter_eq_self_of_subset_right hA]
          _ = Œº (‚ãÉ n, A n ‚à© s) := by rw [@iUnion_inter]
          _ <= ‚àë' n, Œº (A n ‚à© s) := by {
            apply sAdditive_implies_sSubAdditive Œº hŒº
            intro n; exact IsSetAlgebra.inter_mem hAlg (hAS n) hs
            suffices ‚ãÉ n, A n ‚à© s = s by exact mem_of_eq_of_mem this hs
            simp [<- iUnion_inter, inter_eq_self_of_subset_right, hA]
          }
          _ <= ‚àë' n, Œº (A n) := by {
            gcongr
            rename_i n
            specialize hAS n
            have h : A n ‚à© s ‚àà S := by exact IsSetAlgebra.inter_mem hAlg hAS hs
            have h' : A n ‚à© s ‚äÜ A n := by exact inter_subset_left
            have hA : IsSetSemiring S := by exact SetAlgebraIsSetSemiRing hAlg
            apply addContent_mono hA h hAS h'
          }
          _ = ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (A n) := by {
            congr; ext n
            exact Eq.symm (extend_eq (fun s x ‚Ü¶ Œº s) (hAS n))
          }
        ¬∑
          suffices ‚àû <= ‚àë' n, extend (P := Membership.mem S) (fun s x ‚Ü¶ Œº s) (A n) by {
            rw [@top_le_iff] at this
            rw [this]
            simp
          }
          push_neg at hAS
          obtain ‚ü®n, hn‚ü© := hAS
          calc ‚àû = extend (P := Membership.mem S) (fun s x => Œº s) (A n) := by {
            unfold extend
            simp [hn]
          }
          _ <= ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (A n) := by exact ENNReal.le_tsum n
  }

omit mŒ± in
lemma addContent_caratheodory_measurable (s : Set Œ±) (hs : s ‚àà S)
  : (Œº.toOuterMeasure hAlg.empty_mem Œº.empty').IsCaratheodory s := by {
    unfold OuterMeasure.IsCaratheodory
    intro t
    have htsDisjoint : Disjoint (t ‚à© s) (t \ s) := by exact Disjoint.symm disjoint_sdiff_inter
    have htsUnion : t ‚à© s ‚à™ t \ s = t := by exact inter_union_diff t s
    have hSetRing : IsSetRing S := by exact IsSetAlgebra.isSetRing hAlg
    -- generalize_proofs hem Œºem
    apply le_antisymm
    ¬∑ apply measure_le_inter_add_diff
    ¬∑ unfold AddContent.toOuterMeasure inducedOuterMeasure OuterMeasure.ofFunction
      rw [‚Üê OuterMeasure.measureOf_eq_coe]
      simp
      intro A hA
      have h: ‚àÄ(A : ‚Ñï -> Set Œ±) (hAS : ‚àÄn, A n ‚àà S) (n : ‚Ñï),
        extend (P := Membership.mem S) (fun s x => Œº s) (A n) = Œº (A n) := by {
          intro A hAS n;
          exact extend_eq (fun s x ‚Ü¶ Œº s) (hAS n)
        }
      by_cases hAS : ‚àÄn, A n ‚àà S
      ¬∑ have hans : ‚àÄ(A : ‚Ñï -> Set Œ±) (hAS : ‚àÄn, A n ‚àà S) n, A n ‚à© s ‚àà S := by intro A hAS n; exact IsSetRing.inter_mem hSetRing (hAS n) hs
        have hans2 : ‚àÄ(A : ‚Ñï -> Set Œ±) (hAS : ‚àÄn, A n ‚àà S) n, A n \ s ‚àà S := by intro A hAS n; exact hSetRing.diff_mem (hAS n) hs
        have hansU : ‚àÄ(A : ‚Ñï -> Set Œ±) (hAS : ‚àÄn, A n ‚àà S) n, A n ‚à© s ‚à™ A n \ s = A n := by intro A hAS n; exact inter_union_diff (A n) s
        have hansD : ‚àÄ(A : ‚Ñï -> Set Œ±) (hAS : ‚àÄn, A n ‚àà S) n, Disjoint (A n ‚à© s) (A n \ s) := by {
          intro A hAS n
          exact Disjoint.symm disjoint_sdiff_inter
        }
        simp_rw [h A hAS]

        rw [show ‚àë' n, Œº (A n) = ‚àë' n, Œº (A n ‚à© s) + ‚àë' n, Œº (A n \ s) by {
          calc ‚àë' (n : ‚Ñï), Œº (A n) = ‚àë' (n : ‚Ñï), (Œº (A n ‚à© s) + Œº (A n \ s)) := by {
              congr
              ext n
              have h := addContent_union (m := Œº) hSetRing (hans A hAS n) (hans2 A hAS n) (hansD A hAS n)
              rw [hansU A hAS] at h
              exact h
            }
          _ = ‚àë' (n : ‚Ñï), Œº (A n ‚à© s) + ‚àë' (n : ‚Ñï), Œº (A n \ s) := ENNReal.tsum_add
            }]
        gcongr
        ¬∑
          let B n := A n ‚à© s
          have hBS : ‚àÄn, B n ‚àà S := by intro n; exact hans A hAS n
          have hB : t ‚à© s ‚äÜ ‚ãÉ n, A n ‚à© s := by
            calc t ‚à© s ‚äÜ (‚ãÉ n, A n) ‚à© s := by exact inter_subset_inter hA fun ‚¶Éa‚¶Ñ a ‚Ü¶ a
            _ = ‚ãÉ n, A n ‚à© s := by rw [iUnion_inter]

          calc ‚®Ö f : ‚Ñï -> Set Œ±, ‚®Ö (_ : t ‚à© s ‚äÜ ‚ãÉ n, f n), ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (f n)
            <= ‚®Ö (_ : t ‚à© s ‚äÜ ‚ãÉ n, B n), ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (B n) := by apply iInf_le
          _  = ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (B n) := by simp [B, hB]; rfl
          _ = ‚àë' (n : ‚Ñï), Œº (B n) := by congr; ext n; exact h B (hans A hAS) n
          _ = ‚àë' (n : ‚Ñï), Œº (A n ‚à© s) := by simp [B]
        ¬∑
          let B n := A n \ s
          have hBS : ‚àÄn, B n ‚àà S := by intro n; exact hans2 A hAS n
          have hB : t \ s ‚äÜ ‚ãÉ n, A n \ s := by
            calc t \ s ‚äÜ (‚ãÉ n, A n) \ s := by exact inter_subset_inter hA fun ‚¶Éa‚¶Ñ a ‚Ü¶ a
            _ = ‚ãÉ n, A n \ s := by rw [iUnion_diff]

          calc ‚®Ö f : ‚Ñï -> Set Œ±, ‚®Ö (_ : t \ s ‚äÜ ‚ãÉ n, f n), ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (f n)
            <= ‚®Ö (_ : t \ s ‚äÜ ‚ãÉ n, B n), ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (B n) := by apply iInf_le
          _  = ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (B n) := by simp [B, hB]; rfl
          _ = ‚àë' (n : ‚Ñï), Œº (B n) := by congr; ext n; exact h B (hans2 A hAS) n
          _ = ‚àë' (n : ‚Ñï), Œº (A n \ s) := by simp [B]
      ¬∑ push_neg at hAS
        obtain ‚ü®n, hn‚ü© := hAS
        suffices ‚àû <= ‚àë' (i : ‚Ñï), extend (fun s x ‚Ü¶ Œº s) (A i) by {
          rw [@top_le_iff] at this
          rw [this]
          simp
        }
        calc ‚ä§ = extend (P := Membership.mem S) (fun s x ‚Ü¶ Œº s) (A n) := Eq.symm (extend_eq_top (fun s x ‚Ü¶ Œº s) hn)
          _ <= ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (A n) := by exact ENNReal.le_tsum n
}


end MeasureTheory

namespace ProductProbabilityMeasure
open MeasureTheory MeasurableSpace Measurable ProductLike



variable {I : Type*}
variable (Œ© : ‚àÄ(i : I), Type*)
variable [‚àÄi, MeasurableSpace (Œ© i)]
variable (J : Set I)
variable (JF : Finset I)

instance : (i : JF) -> MeasurableSpace (JF.restrict Œ© i) := by {
  intro i
  rw [show JF.restrict Œ© i = Œ© i by rfl]
  infer_instance
}
instance : ‚àÄ(i : J), MeasurableSpace (J.restrict Œ© i) := by {
  intro i
  rw [show J.restrict Œ© i = Œ© i by rfl]
  infer_instance
}
-- √ó_(i ‚àà I) Œ©_i
abbrev ProductSpace := (i: I) -> Œ© i


-- def œÄ (i : I) (œâ : ProductSpace Œ©) := œâ i
def œÄ (J : Set I) : ProductSpace Œ©  -> ProductSpace (J.restrict Œ©) :=
  fun œâ => J.restrict œâ

-- variable (i : I)
-- #check œÄ Œ© {i}

lemma pi_measurable (J : Set I) : Measurable (œÄ Œ© J) := by {
    exact measurable_restrict J
}

-- Ionescu-Tulcea
open ProbabilityMeasure

-- theorem finite_product {I : Type*} [Fintype I] (Œ© : I -> Type*) [‚àÄi, MeasurableSpace (Œ© i)]
--   (P : (i : I) -> ProbabilityMeasure (Œ© i)) :
--   ‚àÉ! ‚Ñô : ProbabilityMeasure (ProductSpace Œ©), ‚àÄA : (i : I) -> Set (Œ© i),
--   ‚Ñô {a : a i ‚àà A i} = Œ† (i : I), P i (A i) := sorry

open ProbabilityTheory
def measurable_equivalence_singleton_product {I : Type*} (Œ± : I -> Type*) (i : I) [‚àÄm, MeasurableSpace (Œ± m)]
  : (‚àÄ(j : ({i} : Set I)), Œ± j) ‚âÉ·µê Œ± i
  := MeasurableEquiv.piUnique (Œ¥' := ({i} : Set I)) (œÄ := fun x => Œ± ‚Üëx)


/- There is no 1 in the kernel composition semigroup, n=0 means choose first kernel -/
def FiniteCompKernelNat
  (n : ‚Ñï)
  {Œ± : ‚Ñï -> Type*}
  [‚àÄm, MeasurableSpace (Œ± m)]
  (K : ‚àÄm, Kernel (‚àÄk: {k|k <= m}, Œ± k) (Œ± (m+1)))
  : Kernel (Œ± 0) (‚àÄk : {k|0 < k ‚àß k <= n+1}, Œ± k) :=
  if hn : n = 0 then
    by {
      let K' := K 0
      rw [show {k | k <= 0} = {0} by {
        ext; simp [hn]
      }] at K'
      simp at K'
      have h : {k | 0 < k ‚àß k <= n + 1} = {1} := by ext; simp [hn]; omega
      rw [h]
      let K'' := change_right K' (measurable_equivalence_singleton_product Œ± 1).symm
      exact change_left K'' (measurable_equivalence_singleton_product Œ± 0)
    }
  else by {
    let n‚ÇÄ := n - 1
    have hn‚ÇÄ : n‚ÇÄ + 1 = n := Nat.succ_pred_eq_of_ne_zero hn
    let K‚ÇÄ := FiniteCompKernelNat n‚ÇÄ K
    let K‚ÇÅ := K n
    simp only [mem_setOf_eq] at K‚ÇÄ
    rw [hn‚ÇÄ] at K‚ÇÄ
    have h : {k | k <= n} = {0} ‚à™ {k | 0 < k ‚àß k <= n} := by ext; simp; omega
    rw [h] at K‚ÇÅ
    have h‚ÇÄ : Fact (0 ‚àâ {k : ‚Ñï | 0 < k ‚àß k <= n}) := ‚ü®by simp‚ü©
    have h‚ÇÅ : Fact (n+1 ‚àâ {k : ‚Ñï | 0 < k ‚àß k <= n}) := ‚ü®by simp‚ü©
    let q : ProdLikeM ((k : ‚Üë{k | 0 < k ‚àß k ‚â§ n + 1}) ‚Üí Œ± ‚Üëk) ((k : ‚Üë{k | 0 < k ‚àß k ‚â§ n}) ‚Üí Œ± ‚Üëk) (Œ± (n + 1)) := by {
      rw [show {k| 0 < k ‚àß k <= n + 1} = {k | 0 < k ‚àß k <= n} ‚à™ {n+1} by ext; simp; omega]
      infer_instance
    }
    exact compProd K‚ÇÄ K‚ÇÅ
  }

-- def Measure.change (Œº : Measure Œ±) := Œº.comapRight


def FiniteCompMeasureKernelNat
  (n : ‚Ñï)
  {Œ± : ‚Ñï -> Type*}
  [‚àÄm, MeasurableSpace (Œ± m)]
  (Œº : Measure (Œ± 0))
  (K : ‚àÄm, Kernel (‚àÄk: {k|k <= m}, Œ± k) (Œ± (m+1)))
  : Measure (‚àÄk : {k|k <= n}, Œ± k) :=
  if hn : n = 0 then
    by {
      rw [show {k | k <= n} = {0} by ext; simp[hn]]
      exact Œº.comap (measurable_equivalence_singleton_product Œ± 0)
    }
  else by {
    let n‚ÇÄ := n - 1
    have hn‚ÇÄ : n‚ÇÄ + 1 = n := Nat.succ_pred_eq_of_ne_zero hn
    let Œº‚ÇÄ := FiniteCompMeasureKernelNat n‚ÇÄ Œº K
    let K‚ÇÅ := K n‚ÇÄ
    let Œº‚ÇÅ := Œº‚ÇÄ ‚äó‚Çò K‚ÇÅ
    rw [show {k| k <= n} = {k | k <= n‚ÇÄ} ‚à™ {n} by ext; simp; omega]
    have h‚ÇÅ : Fact (Disjoint {k | k <= n‚ÇÄ} {n}) := ‚ü®by simp [hn‚ÇÄ]; omega‚ü©
    let œÑ : (‚àÄk : ‚Üë({k | k <= n‚ÇÄ} ‚à™ {n}), Œ± k) ‚âÉ·µê (‚àÄk : {k | k <= n‚ÇÄ}, Œ± k) √ó Œ± n := by {
      let œÑ' := prod_equiv Œ± (J := {k | k<= n‚ÇÄ}) (K:= {n})
      apply MeasurableEquiv.trans œÑ'.symm
      apply MeasurableEquiv.prodCongr
      exact MeasurableEquiv.refl ((i : ‚Üë{k | k ‚â§ n‚ÇÄ}) ‚Üí Œ± ‚Üëi)
      exact measurable_equivalence_singleton_product Œ± n
    }
    rw [<- hn‚ÇÄ] at *
    exact Œº‚ÇÅ.comap œÑ
  }


#check Measure.ext_of_generateFrom_of_iUnion
#check MeasureTheory.ext_of_generate_finite
theorem uniqeness_of_prob_measures [mŒ± : MeasurableSpace Œ±] (Œº ŒΩ : ProbabilityMeasure Œ±)
  {S : Set (Set Œ±)}
  (hSG : mŒ± = generateFrom S) (hS : IsPiSystem S) (he : ‚àÄs ‚àà S, Œº s = ŒΩ s) : Œº = ŒΩ := by {
    ext t ht
    induction t, ht using induction_on_inter with
    | h_eq => exact hSG
    | h_inter => exact hS
    | empty => simp
    | basic t' ht' => {
      specialize he t' ht'
      repeat rw [‚Üê ennreal_coeFn_eq_coeFn_toMeasure]
      norm_cast
    }
    | compl t' ht' h => rw [prob_compl_eq_one_sub ht', prob_compl_eq_one_sub ht', h]
    | iUnion A pd mA hi => {
      rw [measure_iUnion pd mA, measure_iUnion pd mA]
      exact tsum_congr fun b ‚Ü¶ hi b
    }
  }


#check extend_iUnion_le_tsum_nat'

theorem extend_iUnion_le_tsum_nat' {Œ± : Type u_1} {P : Set Œ± ‚Üí Prop}
{m : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal}
(s : ‚Ñï ‚Üí Set Œ±)
  (PU : (‚àÄ (i : ‚Ñï), P (s i)) ‚Üí P (‚ãÉ i, s i))
  (msU : ‚àÄ (hm : ‚àÄ (i : ‚Ñï), P (s i)), m (‚ãÉ i, s i) (PU hm) ‚â§ ‚àë' (i : ‚Ñï), m (s i) (hm i))
  : MeasureTheory.extend m (‚ãÉ i, s i) ‚â§ ‚àë' (i : ‚Ñï), MeasureTheory.extend m (s i)
   := by
  by_cases h : ‚àÄ i, P (s i)
  ¬∑ rw [extend_eq _ (PU h), congr_arg tsum _]
    ¬∑ apply msU h
    funext i
    apply extend_eq _ (h i)
  ¬∑ cases' not_forall.1 h with i hi
    exact le_trans (le_iInf fun h => hi.elim h) (ENNReal.le_tsum i)

#check inducedOuterMeasure_eq_extend'

-- theorem inducedOuterMeasure_eq_extend'
-- {Œ± : Type u_1} {P : Set Œ± ‚Üí Prop} {m : (s : Set Œ±) ‚Üí P s ‚Üí ENNReal}
--   {P0 : P ‚àÖ} {m0 : m ‚àÖ P0 = 0} (PU : ‚àÄ ‚¶Éf : ‚Ñï ‚Üí Set Œ±‚¶Ñ, (‚àÄ (i : ‚Ñï), P (f i)) ‚Üí P (‚ãÉ i, f i))
--   (msU : ‚àÄ ‚¶Éf : ‚Ñï ‚Üí Set Œ±‚¶Ñ (hm : ‚àÄ (i : ‚Ñï), P (f i)), m (‚ãÉ i, f i) ‚ãØ ‚â§ ‚àë' (i : ‚Ñï), m (f i) ‚ãØ)
--   (m_mono : ‚àÄ ‚¶És‚ÇÅ s‚ÇÇ : Set Œ±‚¶Ñ (hs‚ÇÅ : P s‚ÇÅ) (hs‚ÇÇ : P s‚ÇÇ), s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí m s‚ÇÅ hs‚ÇÅ ‚â§ m s‚ÇÇ hs‚ÇÇ)
--   {s : Set Œ±} (hs : P s) :
--   (inducedOuterMeasure m P0 m0) s = MeasureTheory.extend m s := by {
--     ofFunction_eq s (fun _t => extend_mono' m_mono hs) (extend_iUnion_le_tsum_nat' PU msU)
--   }


#check MeasureTheory.OuterMeasure.toMeasure
#check MeasureTheory.inducedOuterMeasure_caratheodory
theorem existence_of_measures [mŒ± : MeasurableSpace Œ±] (hSG : mŒ± = generateFrom S)
  {Œº : AddContent S} (hS : IsSetAlgebra S) (hŒº : Œº.sAdditive)
  : ‚àÉ ŒΩ : Measure Œ±, ‚àÄs ‚àà S,  ŒΩ s = Œº s := by {
    let Œº' := Œº.toOuterMeasure (hS.empty_mem) (Œº.empty')
    have hŒΩ : mŒ± <= Œº'.caratheodory := by {
      have hSC : ‚àÄs ‚àà S, Œº'.IsCaratheodory s := by intro s hs; exact addContent_caratheodory_measurable Œº hS s hs
      rw [hSG]
      refine (generateFrom_le_iff Œº'.caratheodory).mpr ?_
      intro s hs
      exact hSC s hs
    }
    let ŒΩ := Œº'.toMeasure hŒΩ
    have hŒΩ : ‚àÄs ‚àà S, ŒΩ s = Œº s := by {
      intro s hs
      have hŒºŒº' : Œº s = Œº' s := by exact Eq.symm (addContent_outer_measure_equal_on_S Œº hS s hs hŒº)
      rw [hŒºŒº']
      unfold ŒΩ
      simp [OuterMeasure.toMeasure]
      have hsM : MeasurableSet s := by {
        have h := measurableSet_generateFrom hs
        rw [<- hSG] at h
        exact h
      }
      apply Measure.ofMeasurable_apply s hsM
    }
    use ŒΩ
  }









def ProductProbabilityMeasure  {I : Type*} [Fintype I] {Œ© : I -> Type*}
[‚àÄi, MeasurableSpace (Œ© i)] (P : (i : I) -> ProbabilityMeasure (Œ© i)) :
  ProbabilityMeasure (ProductSpace Œ©) := sorry


theorem existence_infinite_product_probability_measure :
‚àÄ(P : (i : I) -> ProbabilityMeasure (Œ© i)),
  ‚àÉ! PP : ProbabilityMeasure (ProductSpace Œ©), ‚àÄ(J : Finset I),
   ProbabilityMeasure.map ‚Ñô (aemeasurable (measurable_restrict J))
    = ProductProbabilityMeasure (J.restrict P) := by {
      sorry
  }








  --  (show AEMeasurable (œÄ Œ© J) (Œº := ‚Üë‚Ñô)
  --  by {
  --   -- exact aemeasurable (pi_measurable Œ© J)
  --   exact aemeasurable (measurable_restrict (J : Set I))
  --   }
    -- )

-/
