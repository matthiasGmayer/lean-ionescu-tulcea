import Mathlib

set_option autoImplicit true
/- open namespaces that you use to shorten names and enable notation. -/
open Function Set Classical ENNReal

/- recommended whenever you define anything new. -/
noncomputable section

namespace MeasureTheory

theorem SetAlgebraIsSetSemiRing (h1 : IsSetAlgebra S) : IsSetSemiring S := by {
  refine IsSetRing.isSetSemiring ?_
  exact IsSetAlgebra.isSetRing h1
}

theorem SetAlgebraFiniteUnion (S : Set (Set Œ±)) (hS : IsSetAlgebra S) (I : Finset (Set Œ±)) (hI : ‚àÄi ‚àà I, i ‚àà S) :
  ‚ãÉ‚ÇÄ I ‚àà S := by {
    induction I using Finset.induction with
    | empty => simp; exact hS.empty_mem
    | insert ha hI => {
      rename_i h a hA
      simp [*] at *
      specialize hA hI.2
      exact hS.union_mem hI.1 hA
    }
  }
open Filter Topology

variable {Œ± : Type*} {S : Set (Set Œ±)} [mŒ± : MeasurableSpace Œ±] (Œº : AddContent S)

namespace AddContent


def mk' (C : Set (Set Œ±)) (hAlg : IsSetAlgebra C) (toFun : Set Œ± -> ‚Ñù‚â•0‚àû) (empty' : toFun ‚àÖ = 0)
  (additivity : ‚àÄs ‚àà C, ‚àÄt ‚àà C, (Disjoint s t) -> toFun (s ‚à™ t) = toFun s + toFun t) : AddContent C where
  toFun := toFun
  empty' := empty'
  sUnion' := by {
    intro I hI hpwdf hclear
    clear hclear
    induction I using Finset.induction_on with
    | empty => simp [empty']
    | insert hx hI=> {
      rename_i s I h
      simp [*] at *
      have hsub := (subset_insert s I)
      have hI' : ‚ÜëI ‚äÜ C := Subset.trans hsub hI
      have hpwd' : (I : Set (Set Œ±)).PairwiseDisjoint id := PairwiseDisjoint.subset hpwdf hsub
      specialize h hI' hpwd'
      rw [<- h]
      have hUI : ‚ãÉ‚ÇÄ ‚ÜëI ‚àà C := SetAlgebraFiniteUnion C hAlg I hI'
      have hs : s ‚àà C := hI (mem_insert s ‚ÜëI)
      have hd : Disjoint s (‚ãÉ‚ÇÄ ‚ÜëI) := by {
        rw [@disjoint_sUnion_right]
        intro t ht
        unfold PairwiseDisjoint Set.Pairwise  at hpwdf
        specialize hpwdf (hsub ht) (mem_insert s ‚ÜëI) (ne_of_mem_of_not_mem ht hx)
        rw [show (Disjoint on id) t s = Disjoint (id t) (id s) from rfl] at hpwdf
        simp at hpwdf
        exact Disjoint.symm hpwdf
      }
      apply additivity s hs (‚ãÉ‚ÇÄ ‚ÜëI) hUI hd
    }
  }


omit mŒ± in
@[simp]
lemma mk'_on_C (C : Set (Set Œ±)) (hAlg : IsSetAlgebra C) (toFun : Set Œ± -> ‚Ñù‚â•0‚àû) (empty' : toFun ‚àÖ = 0)
  (additivity : ‚àÄs ‚àà C, ‚àÄt ‚àà C, (Disjoint s t) -> toFun (s ‚à™ t) = toFun s + toFun t)
  (s : Set Œ±)
  : mk' C hAlg toFun empty' additivity s = toFun s := by rfl

variable (hAlg : IsSetAlgebra S)
open MeasureTheory AddContent OuterMeasure Membership ENNReal MeasurableSpace

def sAdditive : Prop :=
  ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ, (‚àÄ i, (A i) ‚àà S) -> (‚ãÉ i, A i ‚àà S) ‚Üí Pairwise (Disjoint on A) ‚Üí
    Œº (‚ãÉ i, A i) = ‚àë' i, Œº (A i)

def sSubAdditive  : Prop :=
  ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ, (‚àÄ i, (A i) ‚àà S) -> (‚ãÉ i, A i ‚àà S) ‚Üí
    Œº (‚ãÉ i, A i) <= ‚àë' i, Œº (A i)

def sContinuousFromBelow  : Prop :=
  ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ {B : Set Œ± }, (‚àÄ i, (A i) ‚àà S) -> (B ‚àà S) ->
  (Tendsto A atTop (ùìù[‚â§] B)) ->
  Tendsto (Œª n => Œº (A n)) atTop (ùìù (Œº B))

def sContinuousFromAbove  : Prop :=
  ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ (B : Set Œ±), (‚àÄ i, (A i) ‚àà S) -> (B ‚àà S) -> (Œº (A 0) < ‚àû) ->
  (Tendsto A atTop (ùìù[‚â•] B)) ->
  Tendsto (Œª n => Œº (A n)) atTop (ùìù (Œº B))

def sContinuousInEmpty  : Prop :=
  ‚àÄ‚¶ÉA : ‚Ñï ‚Üí Set Œ±‚¶Ñ, (‚àÄ i, (A i) ‚àà S) -> (Œº (A 0) < ‚àû) ->
  (Tendsto A atTop (ùìù ‚àÖ)) ->
  Tendsto (Œª n => Œº (A n)) atTop (ùìù 0)

include hAlg in
lemma sAdditive_implies_sSubAdditive : Œº.sAdditive -> Œº.sSubAdditive := by {
  unfold sAdditive sSubAdditive
  intro h A hA hAU
  sorry
}
lemma sSubAdditive_implies_sAdditive : Œº.sSubAdditive -> Œº.sAdditive := sorry

lemma sAdditive_implies_sContinuousFromBelow : Œº.sAdditive -> Œº.sContinuousFromBelow := sorry
lemma sContinuousFromBelow_implies_sAdditive : Œº.sContinuousFromBelow -> Œº.sAdditive := sorry

lemma sContinuousFromAbove_implies_sContinuousInEmpty : Œº.sContinuousFromAbove -> Œº.sContinuousInEmpty := sorry
lemma sContinuousInEmpty_implies_sContinuousFromAbove : Œº.sContinuousInEmpty -> Œº.sContinuousFromAbove := sorry

lemma sAdditive_implies_sContinuousInEmpty : Œº.sAdditive -> Œº.sContinuousInEmpty := sorry

lemma sContinuousInEmpty_finite_implies_sAdditive : Œº.sContinuousInEmpty ‚àß Œº univ < ‚àû -> Œº.sAdditive := sorry


def toOuterMeasure :=
    inducedOuterMeasure (Œª s : Set Œ± => Œª _ : s ‚àà S => Œº s)


lemma outer_measure_equal_on_S (s : Set Œ±) (hs : s ‚àà S) (hŒº : Œº.sAdditive)
  : Œº.toOuterMeasure hAlg.empty_mem Œº.empty' s = Œº s := by {
      -- generalize h : Œº.toOuterMeasure hAlg.empty_mem Œº.empty' = ŒΩ
      let ŒΩ := Œº.toOuterMeasure hAlg.empty_mem Œº.empty'
      suffices ŒΩ s <= Œº s ‚àß ŒΩ s >= Œº s by exact le_antisymm this.1 this.2
      constructor
      ¬∑
        unfold ŒΩ toOuterMeasure inducedOuterMeasure OuterMeasure.ofFunction
        rw [‚Üê @OuterMeasure.measureOf_eq_coe]
        simp
        let f : ‚Ñï -> Set Œ± := fun n => if n = 0 then s else ‚àÖ
        have hf : ‚ãÉ i, f i = s := by ext; simp [f]
        calc
        ‚®Ö f : ‚Ñï -> Set Œ±, ‚®Ö (_ : s ‚äÜ ‚ãÉ i, f i), ‚àë' (i : ‚Ñï), extend (fun s x ‚Ü¶ Œº s) (f i)
        <= ‚®Ö (_ : s ‚äÜ ‚ãÉ i, f i), ‚àë' (i : ‚Ñï),
          extend (P := mem S) (fun s x ‚Ü¶ Œº s) (f i) := by apply iInf_le
        _ =  ‚àë' (i : ‚Ñï), extend (P := mem S) (fun s x ‚Ü¶ Œº s) (f i) := by simp [hf]
        _ =  Œº s := by {
          unfold f
          simp [apply_ite, extend_eq (fun s x => Œº s)]
          rw [show extend (P := mem S) (fun s x => Œº s) s = Œº s by {
            exact extend_eq (fun s x ‚Ü¶ Œº s) hs
          }]
          rw [show extend (P := mem S) (fun s x => Œº s) ‚àÖ = 0 by {
            have h := extend_eq (fun s x ‚Ü¶ Œº s) hAlg.empty_mem
            simp at h
            exact h
          }]
          simp
        }
      ¬∑
        rw [ge_iff_le]
        unfold ŒΩ toOuterMeasure inducedOuterMeasure OuterMeasure.ofFunction
        rw [‚Üê OuterMeasure.measureOf_eq_coe]
        simp
        intro A hA
        by_cases hAS : ‚àÄn, A n ‚àà S
        ¬∑
          calc Œº s = Œº ((‚ãÉn, A n) ‚à© s) := by rw [inter_eq_self_of_subset_right hA]
          _ = Œº (‚ãÉ n, A n ‚à© s) := by rw [iUnion_inter]
          _ <= ‚àë' n, Œº (A n ‚à© s) := by {
            apply sAdditive_implies_sSubAdditive Œº hAlg hŒº
            intro n; exact IsSetAlgebra.inter_mem hAlg (hAS n) hs
            suffices ‚ãÉ n, A n ‚à© s = s by exact mem_of_eq_of_mem this hs
            simp [<- iUnion_inter, inter_eq_self_of_subset_right, hA]
          }
          _ <= ‚àë' n, Œº (A n) := by {
            gcongr
            rename_i n
            specialize hAS n
            have h : A n ‚à© s ‚àà S := by exact IsSetAlgebra.inter_mem hAlg hAS hs
            have h' : A n ‚à© s ‚äÜ A n := by exact inter_subset_left
            have hA : IsSetSemiring S := by exact SetAlgebraIsSetSemiRing hAlg
            apply addContent_mono hA h hAS h'
          }
          _ = ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (A n) := by {
            congr; ext n
            exact Eq.symm (extend_eq (fun s x ‚Ü¶ Œº s) (hAS n))
          }
        ¬∑
          suffices ‚àû <= ‚àë' n, extend (P := mem S) (fun s x ‚Ü¶ Œº s) (A n) by {
            rw [@top_le_iff] at this
            rw [this]
            simp
          }
          push_neg at hAS
          obtain ‚ü®n, hn‚ü© := hAS
          calc ‚àû = extend (P := mem S) (fun s x => Œº s) (A n) := by {
            unfold extend
            simp [hn]
          }
          _ <= ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (A n) := by exact ENNReal.le_tsum n
  }

omit mŒ± in
lemma caratheodory_measurable (s : Set Œ±) (hs : s ‚àà S)
  : (Œº.toOuterMeasure hAlg.empty_mem Œº.empty').IsCaratheodory s := by {
    unfold OuterMeasure.IsCaratheodory
    intro t
    have htsDisjoint : Disjoint (t ‚à© s) (t \ s) := by exact Disjoint.symm disjoint_sdiff_inter
    have htsUnion : t ‚à© s ‚à™ t \ s = t := by exact inter_union_diff t s
    have hSetRing : IsSetRing S := by exact IsSetAlgebra.isSetRing hAlg
    -- generalize_proofs hem Œºem
    apply le_antisymm
    ¬∑ apply measure_le_inter_add_diff
    ¬∑ unfold AddContent.toOuterMeasure inducedOuterMeasure OuterMeasure.ofFunction
      rw [‚Üê OuterMeasure.measureOf_eq_coe]
      simp
      intro A hA
      have h: ‚àÄ(A : ‚Ñï -> Set Œ±) (hAS : ‚àÄn, A n ‚àà S) (n : ‚Ñï),
        extend (P := Membership.mem S) (fun s x => Œº s) (A n) = Œº (A n) := by {
          intro A hAS n;
          exact extend_eq (fun s x ‚Ü¶ Œº s) (hAS n)
        }
      by_cases hAS : ‚àÄn, A n ‚àà S
      ¬∑ have hans : ‚àÄ(A : ‚Ñï -> Set Œ±) (hAS : ‚àÄn, A n ‚àà S) n, A n ‚à© s ‚àà S := by intro A hAS n; exact IsSetRing.inter_mem hSetRing (hAS n) hs
        have hans2 : ‚àÄ(A : ‚Ñï -> Set Œ±) (hAS : ‚àÄn, A n ‚àà S) n, A n \ s ‚àà S := by intro A hAS n; exact hSetRing.diff_mem (hAS n) hs
        have hansU : ‚àÄ(A : ‚Ñï -> Set Œ±) (hAS : ‚àÄn, A n ‚àà S) n, A n ‚à© s ‚à™ A n \ s = A n := by intro A hAS n; exact inter_union_diff (A n) s
        have hansD : ‚àÄ(A : ‚Ñï -> Set Œ±) (hAS : ‚àÄn, A n ‚àà S) n, Disjoint (A n ‚à© s) (A n \ s) := by {
          intro A hAS n
          exact Disjoint.symm disjoint_sdiff_inter
        }
        simp_rw [h A hAS]

        rw [show ‚àë' n, Œº (A n) = ‚àë' n, Œº (A n ‚à© s) + ‚àë' n, Œº (A n \ s) by {
          calc ‚àë' (n : ‚Ñï), Œº (A n) = ‚àë' (n : ‚Ñï), (Œº (A n ‚à© s) + Œº (A n \ s)) := by {
              congr
              ext n
              have h := addContent_union (m := Œº) hSetRing (hans A hAS n) (hans2 A hAS n) (hansD A hAS n)
              rw [hansU A hAS] at h
              exact h
            }
          _ = ‚àë' (n : ‚Ñï), Œº (A n ‚à© s) + ‚àë' (n : ‚Ñï), Œº (A n \ s) := ENNReal.tsum_add
            }]
        gcongr
        ¬∑
          let B n := A n ‚à© s
          have hBS : ‚àÄn, B n ‚àà S := by intro n; exact hans A hAS n
          have hB : t ‚à© s ‚äÜ ‚ãÉ n, A n ‚à© s := by
            calc t ‚à© s ‚äÜ (‚ãÉ n, A n) ‚à© s := by exact inter_subset_inter hA fun ‚¶Éa‚¶Ñ a ‚Ü¶ a
            _ = ‚ãÉ n, A n ‚à© s := by rw [iUnion_inter]

          calc ‚®Ö f : ‚Ñï -> Set Œ±, ‚®Ö (_ : t ‚à© s ‚äÜ ‚ãÉ n, f n), ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (f n)
            <= ‚®Ö (_ : t ‚à© s ‚äÜ ‚ãÉ n, B n), ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (B n) := by apply iInf_le
          _  = ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (B n) := by simp [B, hB]; rfl
          _ = ‚àë' (n : ‚Ñï), Œº (B n) := by congr; ext n; exact h B (hans A hAS) n
          _ = ‚àë' (n : ‚Ñï), Œº (A n ‚à© s) := by simp [B]
        ¬∑
          let B n := A n \ s
          have hBS : ‚àÄn, B n ‚àà S := by intro n; exact hans2 A hAS n
          have hB : t \ s ‚äÜ ‚ãÉ n, A n \ s := by
            calc t \ s ‚äÜ (‚ãÉ n, A n) \ s := by exact inter_subset_inter hA fun ‚¶Éa‚¶Ñ a ‚Ü¶ a
            _ = ‚ãÉ n, A n \ s := by rw [iUnion_diff]

          calc ‚®Ö f : ‚Ñï -> Set Œ±, ‚®Ö (_ : t \ s ‚äÜ ‚ãÉ n, f n), ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (f n)
            <= ‚®Ö (_ : t \ s ‚äÜ ‚ãÉ n, B n), ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (B n) := by apply iInf_le
          _  = ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (B n) := by simp [B, hB]; rfl
          _ = ‚àë' (n : ‚Ñï), Œº (B n) := by congr; ext n; exact h B (hans2 A hAS) n
          _ = ‚àë' (n : ‚Ñï), Œº (A n \ s) := by simp [B]
      ¬∑ push_neg at hAS
        obtain ‚ü®n, hn‚ü© := hAS
        suffices ‚àû <= ‚àë' (i : ‚Ñï), extend (fun s x ‚Ü¶ Œº s) (A i) by {
          rw [@top_le_iff] at this
          rw [this]
          simp
        }
        calc ‚ä§ = extend (P := Membership.mem S) (fun s x ‚Ü¶ Œº s) (A n) := Eq.symm (extend_eq_top (fun s x ‚Ü¶ Œº s) hn)
          _ <= ‚àë' n, extend (fun s x ‚Ü¶ Œº s) (A n) := by exact ENNReal.le_tsum n
}


def toMeasure (hSG : mŒ± = generateFrom S) (hS : IsSetAlgebra S) (hŒº : Œº.sAdditive) : Measure Œ± := by {
  let Œº' := Œº.toOuterMeasure (hS.empty_mem) (Œº.empty')
  have hŒΩ : mŒ± <= Œº'.caratheodory := by {
    have hSC : ‚àÄs ‚àà S, Œº'.IsCaratheodory s := by intro s hs; exact caratheodory_measurable Œº hS s hs
    rw [hSG]
    refine (generateFrom_le_iff Œº'.caratheodory).mpr ?_
    intro s hs
    exact hSC s hs
  }
  let ŒΩ := Œº'.toMeasure hŒΩ
  have hŒΩ : ‚àÄs ‚àà S, ŒΩ s = Œº s := by {
    intro s hs
    have hŒºŒº' : Œº s = Œº' s := by exact Eq.symm (outer_measure_equal_on_S Œº hS s hs hŒº)
    rw [hŒºŒº']
    unfold ŒΩ
    simp [OuterMeasure.toMeasure]
    have hsM : MeasurableSet s := by {
      have h := measurableSet_generateFrom hs
      rw [<- hSG] at h
      exact h
    }
    apply Measure.ofMeasurable_apply s hsM
  }
  exact ŒΩ
}

lemma toMeasure_eq_on_S (hSG : mŒ± = generateFrom S) (hS : IsSetAlgebra S) (hŒº : Œº.sAdditive)
  (s : Set Œ±) (hs : s ‚àà S) : Œº.toMeasure hSG hS hŒº s = Œº s := by {
    unfold AddContent.toMeasure
    simp
    generalize_proofs h1 h2
    have hŒºŒº' : Œº s = Œº.toOuterMeasure h1 h2 s := by exact Eq.symm (outer_measure_equal_on_S Œº hS s hs hŒº)
    rw [hŒºŒº']
    simp [OuterMeasure.toMeasure]
    have hsM : MeasurableSet s := by {
      have h := measurableSet_generateFrom hs
      rw [<- hSG] at h
      exact h
    }
    apply Measure.ofMeasurable_apply s hsM
  }

theorem existence_of_measures (hSG : mŒ± = generateFrom S)
  {Œº : AddContent S} (hS : IsSetAlgebra S) (hŒº : Œº.sAdditive)
  : ‚àÉ ŒΩ : Measure Œ±, ‚àÄs ‚àà S,  ŒΩ s = Œº s := by {
    use Œº.toMeasure hSG hS hŒº
    intro s hs
    exact toMeasure_eq_on_S Œº hSG hS hŒº s hs
  }
